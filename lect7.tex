\documentclass[12pt]{article}
\usepackage{url,amsmath,setspace,amssymb,amsthm,amsfonts}
%\usepackage{hyperref}


\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6.25in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\heading}[5]{
   \renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox[\textwidth]{
     \begin{minipage}{0.9\textwidth} \onehalfspacing
       {\bf CS 290G -- Introduction to Modern Cryptography} \hfill #2

       {\centering \Large #5
       
       }\medskip

       {\it #3 \hfill #4}
     \end{minipage}
   }
   \end{center}
}

\newcommand{\handout}[3]{\heading{#1}{#2}{Instructor:
Stefano Tessaro}{Scribe: Shiyu Ji}{Lecture #1: #3}}

\setlength{\parindent}{0in}

\newcommand{\eqdef}{\stackrel{def}{=}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\inr}{\in_{\mbox{\tiny R}}}
%\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand{\getsr}{\stackrel{\$}{\gets}}
\newcommand{\st}{\mbox{ s.t. }}
\newcommand{\etal}{{\it et al }}
\newcommand{\into}{\rightarrow}

\newcommand{\Ex}{\mathbb{E}}
\newcommand{\e}{\epsilon}
\newcommand{\ee}{\varepsilon}
\newcommand{\ceil}[1]{{\lceil{#1}\rceil}}
\newcommand{\floor}[1]{{\lfloor{#1}\rfloor}}
\newcommand{\angles}[1]{\langle #1 \rangle}
\newcommand{\Com}{{\sf Com}}
\newcommand{\desc}{{\sf desc}}

\newcommand{\rightstep}[1]{%
$\underrightarrow{\quad #1 \quad}$ }

\newcommand{\leftstep}[1]{%
$\underleftarrow{\quad #1 \quad}$ }

\newcommand{\Adv}{\mathsf{Adv}}
\newcommand{\poly}{\mathsf{poly}}

\newcommand{\tab}{\hspace{0.3in}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorems & Definitions


\newtheorem{theorem}{Theorem}[section]

\newtheorem{claim}[theorem]{Claim}
\newtheorem{subclaim}{Claim}[theorem]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{construction}[theorem]{Construction}
\newtheorem{example}[theorem]{Example}
\newtheorem{algorithm1}[theorem]{Algorithm}
\newtheorem{protocol}[theorem]{Protocol}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{fact}[theorem]{Fact}

%\bibliographystyle{plain}
\usepackage{tikz}
\usetikzlibrary{calc,decorations.pathreplacing}

\begin{document}
\handout{7}{Jan 28, 2016}{Symmetric Encryption}
\section{Symmetric Encryption}
The goal of symmetric encryption is to keep the secrecy of communication between two parties, e.g., Alice and Bob. 
Alice wants to send some message $m$ to Bob via a channel, which is wiretapped by an adversary, Eve.
Alice and Bob share a key $k \in \bits^\lambda$, which is generated by some algorithm $KG$.
Alice first encrypts the message $m$ using $k$: $c \getsr Enc(k,m)$, where $Enc$ is the encryption algorithm (randomized in general), and $c$ is the ciphertext to send. Then Alice sends $c$ through the channel to Bob. After receiving $c$, Bob decrypts and restores the original message $m$: $m \gets Dec(k, c)$. Note that Eve can get the ciphertext $c$ through the channel. Our goal is to hide any information about the message $m$ from Eve.

We can formally define the model above.

\begin{definition}
A {\bf Symmetric Encryption} scheme is a triple of efficient algorithms $SE = (KG, Enc, Dec)$ with the message space $M = \{M_\lambda\}_{\lambda \in \N}$:
\begin{itemize}
\item $KG$: the key generation algorithm (randomized in general). $KG$ samples the shared key $k$: $k \getsr KG(1^\lambda)$, where $\lambda$ is the security parameter (roughly related to the length of the key $k$).
\item $Enc$: the encryption algorithm (randomized in general). $Enc$ outputs the ciphertext $c$: $c \getsr Enc(k, m)$, where $k$ is a valid output of $KG$, and $m$ is an element of the message space $M_\lambda$.
\item $Dec$: the decryption algorithm ({\it deterministic}). $Dec$ restores the message $m$: $m \gets Dec(k, c)$, where $c$ is an output of $Enc$.
\end{itemize}
In addition, we require the scheme above must be correct at least almost:

{\bf Correctness}: $\forall \lambda$, $\forall m \in M_\lambda$: $\Pr[k \getsr KG(1^\lambda) : Dec(k, Enc(k, m)) \not = m]$ is negligible.
\end{definition}

In Lecture 1, we saw One-time Pad (OTP), which is information-theoretically secure. OTP is a concrete example of symmetric encryption.

\begin{example}
\label{eg:1}
One-time Pad (OTP). Let the message space be $M_\lambda = \bits^\lambda$.

\begin{quote}
\centering
\begin{minipage}{.25\textwidth}
$KG(1^\lambda)$:
\begin{enumerate}
\item $k \getsr \bits^\lambda$.
\item {\bf return} $k$.
\end{enumerate}
\end{minipage}
\hspace{.1in}
\begin{minipage}{.25\textwidth}
$Enc(k, m)$:
\begin{enumerate}
\item $c \gets m \oplus k$.
\item {\bf return} $c$.
\end{enumerate}
\end{minipage}
\hspace{.1in}
\begin{minipage}{.25\textwidth}
$Dec(k, c)$:
\begin{enumerate}
\item $m \gets c \oplus k$.
\item {\bf return} $m$.
\end{enumerate}
\end{minipage}
\end{quote}

\end{example}

Last lecture we saw Block Cipher that can be PRP. Block cipher is another example of symmetric encryption.

\begin{example}
\label{eg:bc}
Block Cipher $E : \bits^\lambda \times \bits^\lambda \to \bits^\lambda$. For any $s \in \bits^\lambda$, $E_s(\cdot) \eqdef E(s,\cdot)$ and denote by $E_s^{-1}(\cdot)$ the inverse of $E_s(\cdot)$.

$KG$ is the same as the one in Example \ref{eg:1}.

\begin{quote}
\centering
\begin{minipage}{.4\textwidth}
$Enc(k, m)$:
\begin{enumerate}
\item $c \gets E_k(m)$.
\item {\bf return} $c$.
\end{enumerate}
\end{minipage}
\hspace{.1in}
\begin{minipage}{.4\textwidth}
$Dec(k, c)$:
\begin{enumerate}
\item $m \gets E_k^{-1}(c)$.
\item {\bf return} $m$.
\end{enumerate}
\end{minipage}
\end{quote}

\end{example}

\section{IND-CPA Security}
Our next question is how to formalize the security notion of symmetric encryption. Basically our goal is to hide any information about the message from the adversary, including the following two aspects:
\begin{itemize}
\item When encryting multiple messages, can the adversary learn anything about the messages, e.g., the XOR of some messages?
\item The adversary can launch chosen plaintext attack (CPA), i.e., is the key $k$ leaked when the adversary knows $(c, m)$ s.t. $c \getsr Enc(k, m)$?
\end{itemize}
Up to the notions above, neither OTP nor block cipher is secure. 
Clearly OTP is not secure when encrypting multiple messages with the same key, and for CPA the key $k$ can be easily found: $k = c \oplus m$. 
Even though block cipher can be a PRP, it is \emph{deterministic}, i.e., encrypting the same plaintext always leads to the same ciphertext. We want to hide such information by using randomization.

IND-CPA security is a standard definition about secure symmetric encryption. It can address all the security problems discussed above.
The starting point is to require that for any messages $m_0$, $m_1$, the distributions of $Enc(k, m_0)$ and $Enc(k, m_1)$ are the same for any $k \getsr KG(1^\lambda)$. However, the requirement of identical distributions may be too strong in practice. We can relax it to only computational indistinguishability. \footnote{A PRP block cipher $E$ in Example \ref{eg:bc} can satisfy computational indistinguishability, i.e. $E(k, m_0) \simeq E(k, m_1)$ for any $k \getsr KG(1^\lambda)$ if $E$ is PRP.}

\begin{definition}
\label{def:ic}
Given a symmetric encryption $SE = (KG, Enc, Dec)$, define the following procedure on multiple messages pairs $(m_0, m_1)$:
\begin{quote}
Procedure $LR_b^k(m_0, m_1)$: ($b \in \bits$, $k \getsr KG(1^\lambda)$)
\begin{enumerate}
\item $c \getsr Enc(k, m_b)$.
\item {\bf return} $c$.
\end{enumerate}
\end{quote}

Define the IND-CPA advantage of a distinguisher $D$ as
$$\Adv_{SE}^{ind-cpa}(D) \eqdef \bigg| \Pr[k \getsr KG(1^\lambda) : D^{LR_0^k(\cdot, \cdot)}=1] - \Pr[k \getsr KG(1^\lambda) : D^{LR_1^k(\cdot, \cdot)}=1] \bigg|.$$
Symmetric encryption $SE$ is {\bf IND-CPA secure} if $\Adv_{SE}^{ind-cpa}(D)$ is negligible for all PPT $D$.
\end{definition}

Note that in the query $(m_0, m_1)$ to the oracle $LR_b^k$, $m_0 = m_1$ is possible. In fact this can be very useful since the query $(m_0, m_0)$ can get $Enc(k, m_0)$ for sure.

The following example shows OTP is \emph{not} IND-CPA secure.
\begin{example}
For OTP, we can construct the distinguisher $D_1$ as following:
\begin{quote}
Distinguisher $D_1^{O(\cdot, \cdot)}$: ($O(\cdot, \cdot)$ can be either $LR_0^k(\cdot, \cdot)$ or $LR_1^k(\cdot, \cdot)$)
\begin{enumerate}
\item $c_1 \gets O(0^\lambda, 0^\lambda)$.
\item $c_2 \gets O(0^\lambda, 1^\lambda)$.
\item {\bf if} $c_1 = c_2$ {\bf then return} 1.
\item {\bf else return} 0.
\end{enumerate}
\end{quote}
It is easy to see $\Adv_{SE}^{ind-cpa}(D_1) = 1$. Furthermore, $D_1$ also breaks the block cipher in Example \ref{eg:bc}, and in fact all \emph{deterministic} SE schemes.
\end{example}

\section{Randomized Counter-mode Encryption (\$CTR)}
In this section we give a construction of symmetric encryption that is IND-CPA secure. 

Given a PRF $F : \bits^\lambda \times \bits^\lambda \to \bits^\lambda$, we give $\$CTR = (KG, Enc, Dec)$ with message space $M=\bits^\lambda$ as following:
$KG$ is the same as the one in Example \ref{eg:1}.
\begin{quote}
\begin{minipage}{.4\textwidth}
$Enc(k, m)$:
\begin{enumerate}
\item $r \getsr \bits^\lambda$.
\item $c \gets (r, F(k,r) \oplus m)$.
\item {\bf return} $c$.
\end{enumerate}
\end{minipage}
\hspace{.1in}
\begin{minipage}{.4\textwidth}
$Dec(k, c=(c_1, c_2))$:
\begin{enumerate}
\item $m \gets F(k, c_1) \oplus c_2$.
\item {\bf return} $m$.
\end{enumerate}
// Here $c_1 \gets r$, $c_2 \gets F(k,r) \oplus m$.
\end{minipage}
\end{quote}

The above construction can be made to have $M = \bits^*$, i.e., the message length is not fixed. That is where the term \emph{counter} comes from:
\begin{quote}
$Enc(k, m)$:
\begin{enumerate}
\item represent $m$ as $(m_1, m_2, \cdots, m_t)$ for some $t$. Each $m_i \in \bits^\lambda$.
\item $r \getsr \bits^\lambda$.
\item {\bf for} $i=1$ to $t$ {\bf do}
\item \tab $c_i \gets F(k,r+i) \oplus m_i$.
\item {\bf return} $(r, c_1, c_2, \cdots, c_t)$.
\end{enumerate}
\end{quote}

\begin{quote}
$Dec(k, c=(c_0, c_1, c_2, \cdots, c_t))$:
\begin{enumerate}
\item {\bf for} $i=1$ to $t$ {\bf do}
\item \tab $m_i \gets F(k, c_0+i) \oplus c_i$.
\item {\bf return} $(m_1, m_2, \cdots, m_t)$.
\end{enumerate}
// Here $c_0 \gets r$, $c_i \gets F(k,r+i) \oplus m_i$ for $i\geq 1$.
\end{quote}

However, the generalized version cannot be IND-CPA secure based on Definition \ref{def:ic}, since the ciphertext leaks the length of the message. 
That is, the distinguisher can easily beat the scheme by querying a pair of messages with different lengths.
To avoid this case, we may change the definition of the procudure $LR_b^k$:
\begin{quote}
$LR_b^k(m_0, m_1)$:
\begin{enumerate}
\item {\bf if} $|m_0| = |m_1|$ {\bf then} do as before.
\item {\bf else return} $\bot$.
\end{enumerate}
\end{quote}

Back to the standard model with fixed message length: $M = \bits^\lambda$, we show that \$CTR is IND-CPA secure.
\begin{theorem}
If $F$ is a PRF, then \$CTR is IND-CPA secure.
\end{theorem}
\begin{proof}
For any PPT distinguisher $D$ that makes $q = \poly(\lambda)$ queries, it suffices to show that there exists a PPT distinguisher $D^*$ s.t.
$$\Adv_{\$CTR}^{ind-cpa}(D) \leq 2 \left(\Adv_{F}^{prf}(D^*) + \frac{q^2}{2\cdot 2^\lambda}\right).$$
Before that, we define some immediate oracles:

\begin{quote}
\centering
\begin{minipage}{.4\textwidth}
Procedure $LR_b^k(m_0, m_1)$:
\begin{enumerate}
\item $r \getsr \bits^\lambda$.
\item $c \gets (r, F(k, r) \oplus m_b)$.
\item {\bf return} $c$.
\end{enumerate}
\end{minipage}
\hspace{.1in}
\begin{minipage}{.4\textwidth}
Procedure $\widetilde{LR}_b(m_0, m_1)$:
\begin{enumerate}
\item $r \getsr \bits^\lambda$.
\item $c \gets (r, RF_{\lambda,\lambda}(r) \oplus m_b)$.
\item {\bf return} $c$.
\end{enumerate}
\end{minipage}
\end{quote}
\begin{quote}
\centering
\begin{minipage}{.4\textwidth}
Procedure $R(m_0, m_1)$:
\begin{enumerate}
\item $r \getsr \bits^\lambda$.
\item $c_2 \getsr \bits^\lambda$.
\item {\bf return} $(r, c_2)$.
\end{enumerate}
\end{minipage}
\end{quote}

Now we can rewrite the advantage as
$$\begin{aligned}
& \Adv_{\$CTR}^{ind-cpa}(D) \\
= & \bigg| \Pr[k \getsr KG(1^\lambda) : D^{LR_0^k(\cdot,\cdot)}=1] - \Pr[k \getsr KG(1^\lambda) : D^{LR_1^k(\cdot,\cdot)}=1] \bigg| \\
= & \bigg| \Pr[k \getsr KG(1^\lambda) : D^{LR_0^k(\cdot,\cdot)}=1] - \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1] \\
&+\Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1] - \Pr[D^{R(\cdot,\cdot)}=1] \\
&+\Pr[D^{R(\cdot,\cdot)}=1] - \Pr[D^{\widetilde{LR}_1(\cdot,\cdot)}=1] \\
&+\Pr[D^{\widetilde{LR}_1(\cdot,\cdot)}=1] - \Pr[k \getsr KG(1^\lambda) : D^{LR_1^k(\cdot,\cdot)}=1] \bigg|.
\end{aligned}$$
Define
$$\Delta_1 \eqdef \bigg| \Pr[k \getsr KG(1^\lambda) : D^{LR_0^k(\cdot,\cdot)}=1] - \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1] \bigg|,$$
$$\Delta_2 \eqdef \bigg| \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1] - \Pr[D^{R(\cdot,\cdot)}=1] \bigg|,$$
$$\Delta_3 \eqdef \bigg| \Pr[D^{R(\cdot,\cdot)}=1] - \Pr[D^{\widetilde{LR}_1(\cdot,\cdot)}=1] \bigg|,$$
$$\Delta_4 \eqdef \bigg| \Pr[D^{\widetilde{LR}_1(\cdot,\cdot)}=1] - \Pr[k \getsr KG(1^\lambda) : D^{LR_1^k(\cdot,\cdot)}=1] \bigg|.$$
It is easy to see $\Delta_1 = \Delta_4$ and $\Delta_2 = \Delta_3$ since they are analogous.
By triangle inequality, 
$$\Adv_{\$CTR}^{ind-cpa}(D) \leq \Delta_1 + \Delta_2 + \Delta_3 + \Delta_4 = 2(\Delta_1 + \Delta_2).$$
The remainder of this proof is to give $\Delta_1$ and $\Delta_2$ upper bounds as desired. The following two claims finish the work.

\begin{claim}
\label{clm:d1}
There exists a PPT $D^*$ s.t. $\Delta_1 = \Adv_{F}^{prf}(D^*)$.
\end{claim}
Such a distinguisher $D^*$ can be constructed as following:
\begin{quote}
Distinguisher ${D^*}^O$: (oracle $O$ can be either $F(k,\cdot)$ or $RF_{\lambda,\lambda}$)
\begin{enumerate}
\item $b \getsr D^{\overline{LR}}$.
\item {\bf return} $b$.
\end{enumerate}
\end{quote}
Here the oracle $\overline{LR}$ is defined as the following procedure.
\begin{quote}
Procedure $\overline{LR} (m_0, m_1)$: // $(m_0, m_1)$ is the query.
\begin{enumerate}
\item $r \getsr \bits^\lambda$.
\item $c \gets (r, O(r) \oplus m_0)$.
\item {\bf return} $c$.
\end{enumerate}
\end{quote}
Note that if the oracle $O$ is $F(k,\cdot)$, $\overline{LR}$ simulates $LR_0^k$; if $O$ is $RF_{\lambda,\lambda}$, $\overline{LR}$ simulates $\widetilde{LR}_0$. Hence
$$\Pr[k \getsr \bits^\lambda : {D^*}^{F(k, \cdot)} = 1] = \Pr[k \getsr KG(1^\lambda) : D^{LR_0^k(\cdot,\cdot)} = 1],$$
$$\Pr[{D^*}^{RF_{\lambda,\lambda}} = 1] = \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)} = 1].$$
Since
$$\Adv_{F}^{prf}(D^*) = \bigg|\Pr[k \getsr \bits^\lambda : {D^*}^{F(k, \cdot)} = 1] - \Pr[{D^*}^{RF_{\lambda,\lambda}} = 1]\bigg|,$$
Claim \ref{clm:d1} follows.

\begin{claim}
$\Delta_2 \leq \frac{q^2}{2 \cdot 2^\lambda}$.
\end{claim}
Let $(r,c_2)$ be the answer from $\widetilde{LR}$ or $R$ on the query $(m_0,m_1)$. The only difference between them is that $c_2$ is $RF_{\lambda,\lambda}(r) \oplus m_0$ for $\widetilde{LR}$, but uniformly random for $R$. Thus $\widetilde{LR}$ and $R$ are identical from the view of $D$ as long as the values of $r$ are distinct among the $q$ queries (no collisions). Hence 
$$\begin{aligned}
&\Delta_2 
=  \bigg| \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1] - \Pr[D^{R(\cdot,\cdot)}=1] \bigg| \\
=& \bigg| \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1 \wedge \textrm{$r$ collides}] - \Pr[D^{R(\cdot,\cdot)}=1 \wedge \textrm{$r$ collides}] \\
&+ \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1 \wedge \textrm{no collisions on $r$}] - \Pr[D^{R(\cdot,\cdot)}=1 \wedge \textrm{no collisions on $r$}] \bigg| \\
=& \bigg| \Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1 \wedge \textrm{$r$ collides}] - \Pr[D^{R(\cdot,\cdot)}=1 \wedge \textrm{$r$ collides}] \bigg|\\
=& \bigg| \Pr[\textrm{$r$ collides among $q$ queries}] \cdot (\Pr[D^{\widetilde{LR}_0(\cdot,\cdot)}=1 | \textrm{$r$ collides} ] - \Pr[D^{R(\cdot,\cdot)}=1 | \textrm{$r$ collides}]) \bigg|\\
\leq& \Pr[\textrm{$r$ collides among $q$ queries}] \leq \frac{q^2}{2\cdot 2^\lambda}.
\end{aligned}$$
The last step is given by birthday attack from last lecture.
\end{proof}

\end{document}
