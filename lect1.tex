\documentclass[12pt]{article}
\usepackage{url,amsmath,setspace,amssymb,amsthm,amstext,amsfonts}
%\usepackage{hyperref}


\setlength{\oddsidemargin}{.25in}
\setlength{\evensidemargin}{.25in}
\setlength{\textwidth}{6.25in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\heading}[5]{
   \renewcommand{\thepage}{#1-\arabic{page}}
   \noindent
   \begin{center}
   \framebox[\textwidth]{
     \begin{minipage}{0.9\textwidth} \onehalfspacing
       {\bf CS 290G -- Introduction to Modern Cryptography} \hfill #2

       {\centering \Large #5
       
       }\medskip

       {\it #3 \hfill #4}
     \end{minipage}
   }
   \end{center}
}

\newcommand{\handout}[3]{\heading{#1}{#2}{Instructor:
Stefano Tessaro}{Scribe: Shiyu Ji}{Lecture #1: #3}}

\setlength{\parindent}{0in}

\newcommand{\eqdef}{\stackrel{def}{=}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\bits}{\{0,1\}}
\newcommand{\inr}{\in_{\mbox{\tiny R}}}
%\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand{\getsr}{\stackrel{\$}{\gets}}
\newcommand{\st}{\mbox{ s.t. }}
\newcommand{\etal}{{\it et al }}
\newcommand{\into}{\rightarrow}

\newcommand{\Ex}{\mathbb{E}}
\newcommand{\e}{\epsilon}
\newcommand{\ee}{\varepsilon}
\newcommand{\ceil}[1]{{\lceil{#1}\rceil}}
\newcommand{\floor}[1]{{\lfloor{#1}\rfloor}}
\newcommand{\angles}[1]{\langle #1 \rangle}
\newcommand{\Com}{{\sf Com}}
\newcommand{\desc}{{\sf desc}}

\newcommand{\rightstep}[1]{%
$\underrightarrow{\quad #1 \quad}$ }

\newcommand{\leftstep}[1]{%
$\underleftarrow{\quad #1 \quad}$ }
\newcommand{\Adv}{\textsf{Adv}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorems & Definitions


\newtheorem{theorem}{Theorem}[section]

\newtheorem{claim}[theorem]{Claim}
\newtheorem{subclaim}{Claim}[theorem]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}


\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{construction}[theorem]{Construction}
\newtheorem{example}[theorem]{Example}
\newtheorem{algorithm1}[theorem]{Algorithm}
\newtheorem{protocol}[theorem]{Protocol}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{assumption}[theorem]{Assumption}

\bibliographystyle{plain}

\begin{document}
\handout{2}{Jan 7, 2016}{One-way functions}
\section{Intuitive Example}
One-way functions are easy to compute but hard to invert. Recall the discrete logarithm problem from the last lecture. Denote by $G = \Z_p^*$ the cyclic group generated by an element $g$
$$G = \angles{g} = \{e, g, g^2, g^3, \cdots \},$$
where $e$ is the neutral element, and $g$ is the generator, and all the multiplications are modulo $p$. We assume $p$ is a large prime.
The exponential function is defined as
$$exp_g : \Z_{|G|} \to G,$$
$$exp_g(x) \eqdef g^x \mod p,$$
in which $\Z_{|G|}$ is the additive group modulo $|G|$: $\{0, 1, \cdots, |G|-1\}$. The discrete logarithm problem says when $p$ is very large, the exponential function is efficient to compute, but intractable to invert.

This example satisfies two properties:
\begin{enumerate}
\item $exp_g(x)$ can be computed efficiently. In the group $\Z_p^*$ this means the computation can be done in time like $(\log p)^2$.
\item It cannot be inverted efficiently, i.e., it is hard to find $x$ given $exp_g(x)$. To invert may take time like $p$, $\sqrt{p}$, $\cdots$.
\end{enumerate}

\section{Adversary Advantage}
Given a function $f : D \to R$, which is not necessarily injective. How should we define the hardness of inverting $f$? 
The idea  is to define via a \emph{game}. See Figure \ref{fig:inversion_game}.
\begin{figure}[!ht]
\centering
\begin{tabular}{c c c}
\fbox{Adversary $A$} & & \fbox{Challenger} \\
 & & $x \getsr D$ \\
 & \leftstep{f(x)} & \\
outputs $x' \in D$ given $f(x)$ & & \\
 & \rightstep{x'} & \\
 & & $A$ \emph{wins} iff $f(x) = f(x')$.
\end{tabular}
\caption{The ``inversion game'' used to define the hardness of inverting $f : D \to R$.}
\label{fig:inversion_game}
\end{figure}

In this inversion game, $f$ is a public function, i.e., the adversary $A$ knows everything about $f$. $x \getsr D$ means that $x$ is drawn uniformly at random from $D$, i.e., each element in $D$ can be chosen with probability $1/|D|$.

The adversary $A$ is a (randomized) algorithm that takes an input $y\in R$ and produces an output $x'\in D$.

We can define the advantage of $A$ as its probability to win this game.
\begin{definition}
{\bf Adversary $A$'s Advantage} to invert a function $f : D \to R$:
$$\Adv_f^{owf}(A) = \Pr [x\getsr D, x'\getsr A(f(x)) : f(x)=f(x')].$$
\end{definition}

We have some examples of simple adversaries.
\begin{example}
\begin{figure}[!ht]
\centering
\begin{tabular}{l}
Adversary $A(y)$\\
\hline
$x' \getsr D$\\
{\bf output} $x'$.\\
\end{tabular}
\caption{An adversary $A$ guesses from $D$ at uniformly random.}
\label{fig:rg}
\end{figure}

Consider the adversary $A$ in Figure \ref{fig:rg}. What is the advantage $\Adv_f^{owf}(A)$?
\begin{itemize}
\item If $f$ is injective, then
$$
\begin{aligned}
\Adv_f^{owf}(A) &= \Pr [x\getsr D, x'\getsr D : f(x) = f(x')] \\
&= \Pr [x\getsr D, x'\getsr D : x = x'] = 1/|D|.
\end{aligned}$$

\item If $f : D \to \bits$, then $\Adv_f^{owf}(A) \geq 1/2$.
\end{itemize}
\end{example}

\begin{example}
\begin{figure}[!ht]
\centering
\begin{tabular}{l}
Adversary $A'(y)$\\
\hline
Go through all elements $x'$ in $D$, \\
{\bf until} $f(x')=y$. \\
{\bf Then output} $x'$.\\
\end{tabular}
\caption{An adversary $A'$ searches for the preimage exhaustively.}
\label{fig:bf}
\end{figure}

Consider the adverary $A'$ in Figure \ref{fig:bf}. We have $\Adv_f^{owf}(A) = 1$. However, if $|D|$ is very large, such an adversary $A'$ is computationally infeasible.
\end{example}

\section{Definitions}
Informally, a function $f:D\to R$ is a One-Way Function (OWF) if
\begin{enumerate}
\item $f$ is efficiently computable,
\item For every ``feasible'' adversary $A$, its advantage $\Adv_f^{owf}(A)$ is ``small''.
\end{enumerate}
Here \emph{efficiently computable, ``feasible'', ``small''} need to be formalized.

Instead of a single function $f$, we often think of a family of functions $F = \{f_\lambda\}_{\lambda\in\N}$, in which $\lambda$ is the {\bf security parameter}. Typically, the security parameter $\lambda$ is roughly related to the input length. For example, in $\Z_p^*$, consider the exponential function $exp_g(x) = g^x \mod p$, where $p$ is not fixed. We define a sequence of prime numbers $p_1, p_2, \cdots$, where $p_\lambda$ needs $\lambda$ bits to be described, and $g_\lambda$ is a generator of $\Z_{p_\lambda}^*$. We consider the sequence of functions
$$f_\lambda : \Z_{p_\lambda-1} \to \Z_{p_\lambda}^*$$
$$f_\lambda (x) \eqdef g_\lambda^x \mod p_\lambda. $$
Note that the domain of each $f_\lambda$ does not contain $p_\lambda-1$, since we always have $g_\lambda^{p_\lambda-1} \mod p_\lambda = 1$ by Fermat's little theorem.

Similarly, we can define the advantage of adversary $A$ given a family of functions $F = \{f_\lambda\}_{\lambda\in\N}$, $f_\lambda : D_\lambda \to R_\lambda$.
\begin{definition}
{\bf Adversary $A$'s Advantage} to invert a family of functions $F = \{f_\lambda\}_{\lambda\in\N}$:
$$\Adv_{F,\lambda}^{owf}(A) = \Pr [x\getsr D_\lambda, x'\getsr A(f_\lambda(x), \lambda) : f_\lambda(x)=f_\lambda(x')].$$
\end{definition}

Now we start to formalize the notion of one-way function. We first define efficiently computable functions.
\begin{definition}
A function family $F = \{f_\lambda\}_{\lambda\in\N}$ is efficiently computable if there exists an algorithm \textsf{Eval} such that
\begin{enumerate}
\item For all $\lambda\in\N$, for all $x\in D_\lambda$, we have $\textsf{Eval}(x, \lambda) = f_\lambda(x)$.
\item $\textsf{Eval}(x,\lambda)$ runs in polynomial time of $\lambda$, e.g., $O(\lambda)$, $O(\lambda^2)$, $\cdots$. Typically, it would like to be $O(\lambda)$, $O(\lambda \log \lambda)$, etc.
\end{enumerate}
\end{definition}

``Feasibility'' means polynomial time in $\lambda$.

We next define ``small'', which needs \emph{negligible functions}.
\begin{definition}
A function $f : \N \to [0,1]$ is {\bf negligible} if
$$\forall c\in\N, \exists n_c\in\N, \forall n\geq n_c : f(n) \leq \frac{1}{n^c}.$$
\end{definition}

\begin{example}
$f(n) = 2^{-n}$ is negligible, since by fixing any $c$, one can find an integer $n_c$ s.t. for all $n$ larger than $n_c$, $2^{-n}$ is ever smaller than $n^{-c}$.
\end{example}

\begin{example}
$g(n) = n^{-100}$ and $h(n) = n^{-1000}$ are \emph{not} negligible.
\end{example}

Now we have defined every ingredient of OWF. Hence we can give the formal definition of OWF.
\begin{definition}
$F=\{f_\lambda\}_{\lambda\in\N}$ is a {\bf one-way function} family if
\begin{enumerate}
\item $F$ is efficiently computable.
\item For all polynomial time adversaries $A$ (in $\lambda$), $\Adv_{F,\lambda}^{owf}(A)$ is negligible.
\end{enumerate}
\end{definition}

We can build a OWF given another OWF. This property is reflected in the next lemma.
\begin{lemma}
Assume we are given a function family $F = \{f_\lambda\}$\footnote{Very often $ \{f_\lambda\}$ is short for $ \{f_\lambda\}_{\lambda\in\N}$.}.
We build another function family $G = \{g_\lambda\}$ s.t.
$$g_\lambda : D_\lambda \times D_\lambda \to R_\lambda \times D_\lambda,$$
$$g_\lambda(u,v) \eqdef (f(u), v).$$
If $F$ is one-way, then so is $G$.
\end{lemma}
\begin{proof}
The proof idea is by reduction, i.e., show that the ability to invert $G$ implies the ability to invert $F$.

Assume $G$ is not one-way. Then there exists a PPT \footnote{PPT is short for \emph{probabilistic polynomial time}.} adversary $A$ such that the advantage $\epsilon(\lambda) \eqdef \Adv_{G,\lambda}^{owf}(A)$ is \emph{not} negligible. We claim that we can construct a PPT adversary $A'$ s.t. $\Adv_{F,\lambda}^{owf}(A') \geq \epsilon(\lambda)$. That implies $F$ cannot be one-way, and thus we reach a contradiction and hence $G$ must be one-way. The construction of $A'$ is given in Figure \ref{fig:ad}.

\begin{figure}[!ht]
\centering
\begin{tabular}{l}
Adversary $A'(y,\lambda)$, $y\in R_\lambda$\\
\hline
$v \getsr D_\lambda$ \\
$(u',v') \getsr A((y,v),\lambda)$ \\
{\bf output} $u'$.\\
\end{tabular}
\caption{The adversary $A'$ in the proof of the Lemma.}
\label{fig:ad}
\end{figure}

We can verify our claim by computing the advantage:
$$
\begin{aligned}
\Adv_{F,\lambda}^{owf} (A') 
&= \Pr [u\getsr D_\lambda, u'\getsr A'(f_\lambda(u), \lambda) : f_\lambda(u) = f_\lambda(u')] \\
&= \Pr [u\getsr D_\lambda, v\getsr D_\lambda, (u', v')\getsr A((f_\lambda(u), v), \lambda) : f_\lambda(u) = f_\lambda(u')] \\
&\geq \Pr [u\getsr D_\lambda, v\getsr D_\lambda, (u', v')\getsr A(g_\lambda(u, v), \lambda) : f_\lambda(u) = f_\lambda(u'), v' = v] \\
&= \Pr [u\getsr D_\lambda, v\getsr D_\lambda, (u', v')\getsr A(g_\lambda(u, v), \lambda) : g_\lambda(u, v) = g_\lambda(u', v')] \\
&= \Adv_{G,\lambda}^{owf}(A) = \epsilon(\lambda). \\
\end{aligned}
$$
\end{proof}
\end{document}
